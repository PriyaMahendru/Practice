->Make the instance variables private and use getters(accessors) and setters(mutators)to make them available for other class's use.It gives them security.You set your accessible methods for others i. e your code's API.ALWAYS

Inheritance is for:
For code reusability.To promote polymorphism.

The methods that you can call on a reference are totally dependent on the declared type of the variable, no matter what the actual object is, that the reference is referring to.
The method invocations are based solely on the declared type of the reference, regardless of the object type.
#Simula is the first object oriented programming language.
#Smalltalk is considered the first truly object-oriented programming language.

Polymorphism!
You can declare a reference of interface which refers to any object of the class that implements the interface.
A  reference variable can refer to an object of same type as the declared ref or any subtype of the declared type!
#First extends then implements!
#At runtime the ONLY things that are dynamically selected based on the actual object(rather than the ref type) are instance methods.Not static methods.Not variables.Only overridden instance methods are dynamically invoked based on the real object's type.
Abstract methods must be implemented by the first concrete subclass unless it is also abstract.
Important Rules for overriding a method:
1)Argument list must be same.
2)access level cannot be more restrictive but can be less
3)you can override a method which you have inherited.
4)You can throw any unchecked except but the checked ones should not be new or out of the scope of the original method.
5)Overriding method should not declare exceptions which it will never throw!
5)Static and final methods cannot be overridden

Parent Class method  -super.method()
interface- interfacename.super.method()

If a method is overridden but you use a polymorphic (supertype) reference to refer to the subtype object with the overriding method, the compiler assumes you’re calling the supertype version of the method. If the supertype version declares a checked exception, but the overriding subtype method does not, the compiler still thinks you are calling a method that declares an exception. Let’s look at an example:


This code will not compile because of the exception declared on the Animal eat() method. This happens even though, at runtime, the eat() method used would be the Dog version, which does not declare the exception.

Overloading Rules:

Overloaded methods MUST change the argument list.
Overloaded methods CAN change the return type.
Overloaded methods CAN change the access modifier.
Overloaded methods CAN declare new or broader checked exceptions.
A method can be overloaded in the same type or in a subtype. In other words, if class A defines a doStuff(int i) method, then subclass B could define a doStuff(String s) method without overriding the superclass version that takes an int. So two methods with the same name but in different types can still be considered overloaded if the subtype inherits one version of the method and then declares another overloaded version in its type definition.

To summarise, which overridden version of the method to call (in other words, from which class in the inheritance tree) is decided at runtime based on object type, but which overloaded version of the method to call is based on the reference type of the argument passed at compile time.

Polymorphism works in overriding not Overloading.overriding dominates Overloading if both happens at the same time for polymorphism.

Concrete classes means non abstract classes.
only Covariant return type changes are allowed for overriding methods!

Returning a value:
1)We can return a null in a method with an object reference return type.
2)In a method with a primitive return type, you can return any value which can be implicitly or explicitly converted to the declared returned type.Eg. char compatible with int.
3)With void : return; is perfectly legal.
4)If we declare a class or interface return type then we can return any object that passes the IS-A test.

Constructor Chaining:
Every const invokes the const of its superclass with an implicit call to the super(),unless the constructor invokes an overloaded const of the same class.
Assume horse extends Animal then we have when "Horse h=new Horse();"\-->1.main() calls new Horse()2.horse() calls super()3.Animal calls super().4Object()5.Explicit values to instance variables of Object then of Animal then of Horse.
Default constructor super then parameterised constructor super then object().
Only static variables can be accessed as a part of the call to super() or this().Eg super(Animal.NAME)IS OK
Abstract classes have constructor ,called when concrete class is instantiated
Interfaces do not have Constructor,not a part of object inheritance tree.
Only a Constructor can invoke another Constructor.
If a class has no Constructor at all then compiler will create one.If we have a parameterised Constructor and we need one default but have not created one so we do need to create one on our own!
Default will : have no args,same access modifier as class and call to super() no arg Constructor.
If you have not explicitly given a call to super(),compiler will always give one on its own.
Compiler will call only the no-arg super constructor!
Not implementing a method means not even giving {} !
First line in a constructor must be a call to super() or this().
Constructor can ever have both a call to super() and this().

Singleton Design Pattern:
Wikipedia currently defines a design pattern as “a general reusable solution to a commonly occurring problem within a given context.”
1)Also called creational design pattern.
2)We can have only one instance of a class within an application.

The key parts of the singleton pattern are

A private static variable to store the single instance called the singleton. This variable is usually final to keep developers from accidentally changing it.
A public static method for callers to get a reference to the instance.
A private constructor so no callers can instantiate the object directly.
Remember, the code doesn’t create a new Show each time, but merely returns the singleton instance of Show each time getInstance() is called.
creates the Show object before we need it. This is called eager initialization, which is good if the object isn’t expensive to create or we know it will be needed every time the program runs. Sometimes, however, we want to create the object only on the first use. This is called lazy initialization.
The singleton code is NOT thread-safe. What if this were a web site and two users managed to be booking a seat at the exact same time? If getInstance() were running at the exact same time, both of them could see that INSTANCE was null and create a new Show at the same time. There are a few ways to solve this. One is to add synchronized to the getInstance() method. This works, but comes with a small performance hit. We’re getting way beyond the scope of the exam, but you can Google “double checked locked pattern”
Can use enum instead of singleton but they came in java 5.

IMMUTABLE CLASSES :
Class must be declared as final (So that child classes can’t be created)
• Data members in the class must be declared as private and final (So that we can’t change the value of it after object creation)
• If the constructor takes any mutable objects as arguments, make new copies of those objects in the constructor.
4.Do NOT provide any setter methods!
.If any of the getter methods return a mutable object reference, make a copy of the actual object, and return a reference to the copy.
• Getter method for all the variables in it

INITIALIZATION BLOCKS:
Static initialization blocks run when the class is first loaded, and instance initialization blocks run whenever an instance is created (a bit similar to a constructor).
init blocks execute in the order in which they appear.
Static init blocks run once, when the class is first loaded.
Instance init blocks run every time a class instance is created.
Instance init blocks run after the constructor’s call to super().

Statics :
main() is itself a static method and thus isn’t running against any particular instance of the class; instead it’s running on the class itself. A static method can’t access a nonstatic (instance) variable because there is no instance! That’s not to say there aren’t instances of the class alive on the heap, but rather that even if there are, the static method doesn’t know anything about them. The same applies to instance methods; a static method can’t directly invoke a nonstatic method. Think static = class, nonstatic = instance. Making the method called by the JVM (main()) a static method means the JVM doesn’t have to create an instance of your class just to start running code.
-If a child class extends from another class that has only one constructor that takes a value,then the child class must explicitly declare atleast one constructor.
